## 문제
<https://www.acmicpc.net/problem/1781>

## 풀이
[2109](https://velog.io/@bon0057/CC-%EB%B0%B1%EC%A4%80-2109%EB%B2%88-%EC%88%9C%ED%9A%8C%EA%B0%95%EC%97%B0)번 문제와 같은 데드라인 스케쥴링 문제이다. 문제의 유형이 똑같아서 같은 풀이로 풀었더니 시간초과로 굉장히 많이 헤매었다. 2109번 문제의 경우 N의 범위가 10,000이하이기에 시간복잡도가 O(N^2)이더라도 충분히 해결할 수 있는 반면 1781번 문제는 N의 범위가 200,000이하이므로 O(N^2)의 시간복잡도를 가지는 풀이로는 풀 수 없다. 이 알고리즘에서 시간복잡도를 줄일 수 있는 부분이 데드라인 보다 작고 다른 일정이 배정되지 않은 최대 위치에 배정하는 부분이다. 기존의 알고리즘은 선형적으로 반복문을 통해 찾았기에 O(N^2)이 나왔던 것이고 구글링을 통해 Union-Find 알고리즘을 통해 이 부분을 O(logN)으로 줄일 수 있다는 것을 알았다.

내가 푼 것과 같이 이윤을 기준으로 내림차순으로 푸는 알고리즘도 있는 반면 데드라인을 기준으로 오름차순으로 해결하는 방식도 있었다. 데드라인 스케쥴링 문제에서 두 풀이 모두 적절히 사용할 줄 알아야 할 듯하다.

